<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Searches</title>
    <script src="js/three.min.js"></script>
    <script src="js/controls/TrackballControls.js"></script>
    <link rel="stylesheet" href="css/style.css"/>
</head>
<body>
    <div id="container"></div>
</body>

<script type="text/javascript">
// CONSTANTS
var WIDTH = window.innerWidth,
    HEIGHT = window.innerHeight;

var VIEW_ANGLE = 45,
    ASPECT = WIDTH / HEIGHT,
    NEAR = 0.1,
    FAR = 10000;

// scene variables
var container, renderer, camera, scene, controls;

// start scene
init();
animate();

function init() {
    // get the DOM element to attach to
    container = document.getElementById('container');

    // create a WebGL renderer, camera, and scene
    renderer = new THREE.WebGLRenderer();
    camera = new THREE.PerspectiveCamera(
                                          VIEW_ANGLE,
                                          ASPECT,
                                          NEAR,
                                          FAR
                                        );
    scene = new THREE.Scene();

    // the camera starts at 0,0,0 so pull it back
    camera.position.z = 1200;

    // start the renderer
    renderer.setSize(WIDTH, HEIGHT);

    // attach the render-supplied DOM element
    container.appendChild(renderer.domElement);

    // and the camera
    scene.add(camera);

    // add controls
    controls = new THREE.TrackballControls(camera);
    controls.rotateSpeed = 1.0;
    controls.zoomSpeed = 1.2;
    controls.panSpeed = 0.8;
    controls.noZoom = false;
    controls.noPan = true;
    controls.staticMoving = true;
    controls.dynamicDampingFactor = 0.3;

    // rerender scene on change
    controls.addEventListener( 'change', render );

    // create a point light
    var pointLight = new THREE.PointLight(0xFFFFFF);
    pointLight.position.set(10, 50, 130);
    scene.add(pointLight);

    // create ambient light
    var ambientLight = new THREE.AmbientLight(0x0000aa);
    scene.add(ambientLight);

    // set node sphere properties
    var nodeRadius = 5, nodeSegments = 8, nodeRings = 8,
        nodeGeometry = new THREE.SphereGeometry(nodeRadius, nodeSegments, nodeRings),
        nodeMaterial = new THREE.MeshLambertMaterial({ color: 0xcc0000 }),
        lineMaterial = new THREE.LineBasicMaterial({ color: 0x666666});

    // set edge line properties
    var line = new THREE.Line(lineGeometry, lineMaterial),
        lineGeometry = new THREE.Geometry();

    // radius of node cloud
    var cloudRadius = 900/2;

    for (var i = 0; i < 1000; i++) {
        var x = -1 + Math.random() * 2,
            y = -1 + Math.random() * 2,
            z = -1 + Math.random() * 2,
            d = 1 / Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2) + Math.pow(z, 2));

        x *= d;
        y *= d;
        z *= d;

        x *= Math.pow(Math.random(), 1/3) * cloudRadius;
        y *= Math.pow(Math.random(), 1/3) * cloudRadius;
        z *= Math.pow(Math.random(), 1/3) * cloudRadius;

        var nodeSphere = new THREE.Mesh(nodeGeometry, nodeMaterial);

        nodeSphere.position.set(x, y, z);
        lineGeometry.vertices.push(new THREE.Vector3(x, y, z));

        scene.add(nodeSphere);
    }

    //scene.add(line);

    window.addEventListener('resize', onWindowResize, false);
    render();
}

function animate() {
    requestAnimationFrame(animate);
    controls.update();
}

function render() {
    renderer.render(scene, camera);
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize(window.innerWidth, window.innerHeight);

    controls.handleResize();
    render();
}

function sleep(millis, callback) {
    setTimeout(function()
            { callback(); }
    , millis);
}
</script>
</html>
